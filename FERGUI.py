# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'FERGUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os.path
import sys

import cv2
import numpy as np
import torch
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import QTimer, Qt
from PyQt5.QtGui import QImage, QPixmap, QPainter, QFont, QPen
from PyQt5.QtWidgets import QMessageBox, QScrollArea
from PyQt5.QtChart import QChartView, QChart, QSplineSeries, QValueAxis, QBarSeries, QBarSet,QAbstractBarSeries

from torchvision import transforms

from models.Detect.DBFaceSmallH import DBFace
from models.EmotionRecoginze import Resnet
from models.EmotionRecoginze.kvit import kvit_pretrained
from uties import common
import torch.nn.functional as Functional

global video_path, labLst


class Ui_MainWindow(object):
    def __init__(self):

        self.count = 0

        self.lineaxisY = QValueAxis()
        self.lineaxisX = QValueAxis()
        self.lineseries4 = QSplineSeries()
        self.lineseries3 = QSplineSeries()
        self.lineseries2 = QSplineSeries()
        self.lineseries1 = QSplineSeries()
        self.lineseries0 = QSplineSeries()
        self.linechart = QChart()


        self.barchart = QChart()
        self.barseries = QBarSeries()
        self.barchart.setTitle("表情柱状图")
        self.baraxisY = QValueAxis()
        self.baraxisY.setRange(0, 100)
        self.baraxisY.setLabelFormat('%d')
        self.baraxisY.setTickCount(6)
        self.baraxisY.setLabelsVisible(True)




        self.time_histogram = QTimer() # 动态柱状图定时器
        self.time_lineChart =QTimer()  # 动态直方图定时器
        self.timer_camera = QTimer()  # 定义定时器

    def setupUi(self, MainWindow):

        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1350, 1190)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_6.setObjectName("gridLayout_6")
        self.gridLayout_5 = QtWidgets.QGridLayout()
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.gridLayout_6.addLayout(self.gridLayout_5, 0, 0, 1, 2)

        '''
           任务选择区  
        '''
        self.TaskSelection = QtWidgets.QGroupBox(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.TaskSelection.sizePolicy().hasHeightForWidth())
        self.TaskSelection.setSizePolicy(sizePolicy)
        self.TaskSelection.setObjectName("TaskSelection")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.TaskSelection)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.gridLayout_5.addWidget(self.TaskSelection, 0, 0, 1, 2)

        # 中枢干预任务
        self.btn_CentralEmotion = QtWidgets.QRadioButton(self.TaskSelection)
        self.btn_CentralEmotion.setObjectName("btn_CentralEmotion")
        self.gridLayout_2.addWidget(self.btn_CentralEmotion, 0, 1, 1, 1)
        self.btn_CentralEmotion.clicked.connect(self.centralEmotions)

        # 外周干预任务
        self.btn_PeripheralEmotion = QtWidgets.QRadioButton(self.TaskSelection)
        self.btn_PeripheralEmotion.setObjectName("btn_PeripheralEmotion")
        self.gridLayout_2.addWidget(self.btn_PeripheralEmotion, 1, 1, 1, 1)
        self.btn_PeripheralEmotion.clicked.connect(self.peripheralEmotions)

        '''
           视频播放区
        '''
        self.VideoPlayArea = QtWidgets.QGroupBox(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.VideoPlayArea.sizePolicy().hasHeightForWidth())
        self.VideoPlayArea.setSizePolicy(sizePolicy)
        self.VideoPlayArea.setObjectName("VideoPlayArea")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.VideoPlayArea)
        self.gridLayout_3.setObjectName("gridLayout_3")

        # 视频播放 label
        self.label_VideoPlay = QtWidgets.QLabel(self.VideoPlayArea)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_VideoPlay.sizePolicy().hasHeightForWidth())
        self.label_VideoPlay.setSizePolicy(sizePolicy)
        self.label_VideoPlay.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_VideoPlay.setObjectName("label_VideoPlay")
        self.gridLayout_3.addWidget(self.label_VideoPlay, 0, 0, 1, 1)
        self.gridLayout_5.addWidget(self.VideoPlayArea, 0, 2, 2, 1)

        '''
           按钮区
        '''
        self.ButtonArea = QtWidgets.QGroupBox(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ButtonArea.sizePolicy().hasHeightForWidth())
        self.ButtonArea.setSizePolicy(sizePolicy)
        self.ButtonArea.setObjectName("ButtonArea")
        self.gridLayout = QtWidgets.QGridLayout(self.ButtonArea)
        self.gridLayout.setObjectName("gridLayout")
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem, 12, 1, 1, 1)
        self.gridLayout_5.addWidget(self.ButtonArea, 1, 0, 1, 2)

        # 停止 button
        self.btn_Stop = QtWidgets.QPushButton(self.ButtonArea)
        self.btn_Stop.setObjectName("btn_Stop")
        self.gridLayout.addWidget(self.btn_Stop, 5, 1, 1, 1)
        self.btn_Stop.clicked.connect(self.stop)

        # 继续 button
        self.btn_Continue = QtWidgets.QPushButton(self.ButtonArea)
        self.btn_Continue.setObjectName("btn_Continue")
        self.gridLayout.addWidget(self.btn_Continue, 7, 1, 1, 1)
        self.btn_Continue.clicked.connect(self.ContinuePlay)
        # 选择视频 button
        self.btn_SelectVideo = QtWidgets.QPushButton(self.ButtonArea)
        self.btn_SelectVideo.setObjectName("btn_SelectVideo")
        self.gridLayout.addWidget(self.btn_SelectVideo, 1, 1, 1, 1)
        self.btn_SelectVideo.clicked.connect(self.selectVideo)
        # 清除 button
        self.btn_Clean = QtWidgets.QPushButton(self.ButtonArea)
        self.btn_Clean.setObjectName("btn_Clean")
        self.gridLayout.addWidget(self.btn_Clean, 11, 1, 1, 1)
        self.btn_Clean.clicked.connect(self.cleanData)
        # 保存 button
        self.btn_Save = QtWidgets.QPushButton(self.ButtonArea)
        self.btn_Save.setObjectName("btn_Save")
        self.gridLayout.addWidget(self.btn_Save, 9, 1, 1, 1)
        self.btn_Save.clicked.connect(self.saveData)
        # 开始 button
        self.btn_Start = QtWidgets.QPushButton(self.ButtonArea)
        self.btn_Start.setObjectName("btn_Start")
        self.gridLayout.addWidget(self.btn_Start, 3, 1, 1, 1)
        self.btn_Start.clicked.connect(self.start)

        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem1, 9, 2, 1, 1)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem2, 9, 0, 1, 1)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem3, 1, 0, 1, 1)
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem4, 11, 2, 1, 1)
        spacerItem5 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem5, 0, 1, 1, 1)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem6, 3, 2, 1, 1)
        spacerItem7 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem7, 11, 0, 1, 1)
        spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem8, 3, 0, 1, 1)
        spacerItem9 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem9, 1, 2, 1, 1)
        spacerItem10 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem10, 8, 1, 1, 1)
        spacerItem11 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem11, 7, 2, 1, 1)
        spacerItem12 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem12, 10, 1, 1, 1)
        spacerItem13 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem13, 6, 1, 1, 1)
        spacerItem14 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem14, 4, 1, 1, 1)
        spacerItem15 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem15, 5, 0, 1, 1)
        spacerItem16 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem16, 7, 0, 1, 1)
        spacerItem17 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem17, 5, 2, 1, 1)
        spacerItem18 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem18, 2, 1, 1, 1)
        spacerItem19 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem19, 0, 2, 1, 1)
        spacerItem20 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem20, 1, 2, 1, 1)
        spacerItem21 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem21, 0, 0, 1, 1)
        spacerItem22 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem22, 1, 0, 1, 1)




        self.EmoAnalysis = QtWidgets.QGroupBox(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.EmoAnalysis.sizePolicy().hasHeightForWidth())
        self.EmoAnalysis.setSizePolicy(sizePolicy)
        self.EmoAnalysis.setObjectName("EmoAnalysis")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.EmoAnalysis)
        self.gridLayout_4.setObjectName("gridLayout_4")

        # 柱状图绘制区
        self.Barchartview = QChartView(self.EmoAnalysis)
        self.Barchartview.setEnabled(True)
        self.Barchartview.setObjectName("Barchart")
        self.gridLayout_4.addWidget(self.Barchartview, 0, 0, 1, 1)
        # 折线图绘制区
        self.Linechartview = QChartView(self.EmoAnalysis)
        self.Linechartview.setObjectName("Linechart")
        self.gridLayout_4.addWidget(self.Linechartview, 0, 1, 1, 1)
        self.gridLayout_6.addWidget(self.EmoAnalysis, 1, 0, 1, 2)

        MainWindow.setCentralWidget(self.centralwidget)


        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.VideoPlayArea.setTitle(_translate("MainWindow", "视频播放区"))
        self.label_VideoPlay.setText(_translate("MainWindow", "TextLabel"))
        self.ButtonArea.setTitle(_translate("MainWindow", "按钮区"))
        self.btn_Stop.setText(_translate("MainWindow", "停止"))
        self.btn_Continue.setText(_translate("MainWindow", "继续"))
        self.btn_SelectVideo.setText(_translate("MainWindow", "选择视频"))
        self.btn_Clean.setText(_translate("MainWindow", "清除数据"))
        self.btn_Save.setText(_translate("MainWindow", "保存数据"))
        self.btn_Start.setText(_translate("MainWindow", "开始"))
        self.TaskSelection.setTitle(_translate("MainWindow", "任务选择区"))
        self.btn_CentralEmotion.setText(_translate("MainWindow", "中枢干预-表情识别"))
        self.btn_PeripheralEmotion.setText(_translate("MainWindow", "外周干预-表情识别"))
        self.EmoAnalysis.setTitle(_translate("MainWindow", "表情分析区"))

    def peripheralEmotions(self):
        global labLst
        labLst = ['PA', 'TI', 'ST', 'NE', 'UNKNOW']
        data = [0,0,0,0,0]
        self.draw_barchart(data)
        self.draw_linechart(data)
        print(labLst)

    def centralEmotions(self):
        global labLst
        labLst = ['SU', 'HA', 'SA', 'AN', 'NE']
        data = [0,0,0,0,0]
        self.draw_barchart(data)
        self.draw_linechart(data)
        print(labLst)

    def selectVideo(self):
        global video_path
        video_path_0 = QtWidgets.QFileDialog.getOpenFileName(None, "选择视频",
                                                             "D:/projects  of  python/ZXY_emotionRecognization/FER_Patient/testdata",
                                                             "Image files(*.mp4 *.avi)")  # 起始路径
        video_path = video_path_0[0]  # 获取视频名称
        self.label_VideoPlay.setText(video_path)

    def start(self):
        global video_path,lastDatas

        if video_path == '':
            msy_box = QMessageBox(QMessageBox.Warning, "Warning", "请选择视频!")
            msy_box.exec_()
        else:
            print("开始播放")
            self.FERrec = Video_FER(source=video_path, device='cuda:0', model_name="FERPCVT", has_plt=True)

            print("寻找患者")
            if self.FERrec.testDetect():
                print("患者检测成功")

                self.startDataClean()

                self.cap = cv2.VideoCapture(video_path)
                self.timer_camera.start(30)
                self.timer_camera.timeout.connect(self.openFrame)
                #
                self.time_histogram.start(100)
                self.time_histogram.timeout.connect(self.change_barchart)

                self.time_lineChart.start(100)
                self.time_lineChart.timeout.connect(self.change_linechart)
            else:
                print("患者检测失败")

    def stop(self):

        self.cap.release()

        self.timer_camera.stop()
        self.time_histogram.stop()
        self.time_lineChart.stop()

    def cleanData(self):
        self.cap.release()
        self.startDataClean()

    def saveData(self):
        global video_path
        img1 = self.Barchartview.grab()
        img2 = self.Linechartview.grab()
        save_namepath = video_path.split('.')[0]

        save_line_path = os.path.join(save_namepath+'_linechart'+'.png')
        save_bar_path = os.path.join(save_namepath + '_barchart' + '.png')
        img1.save(save_bar_path)
        img2.save(save_line_path)


    def ContinuePlay(self):
        self.timer_camera.start()
        self.time_histogram.start()
        self.time_lineChart.start()

    def startDataClean(self):
        self.count = 0
        self.lineseries0.clear()
        self.lineseries1.clear()
        self.lineseries2.clear()
        self.lineseries3.clear()
        # self.lineseries4.clear()

        self.barseries.clear()

        self.label_VideoPlay.clear()


    def openFrame(self):
        global predDatas
        if self.FERrec.testDetect():
            # print("开始识别")
            frame = self.FERrec.Detect()[0]
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            height, width, bytesPerComponent = frame.shape
            bytesPerLine = bytesPerComponent * width
            q_image = QImage(frame.data, width, height, bytesPerLine,
                             QImage.Format_RGB888).scaled(self.label_VideoPlay.width(),
                                                          self.label_VideoPlay.height())
            self.label_VideoPlay.setPixmap(QPixmap.fromImage(q_image))

    def draw_barchart(self,data):

        self.barseries.clear()
        for i in range(len(labLst)-1):
            setTemp = QBarSet(labLst[i])
            temp = data[i] * 100
            setTemp.append(temp)
            self.barseries.append(setTemp)

        self.barseries.setLabelsVisible(True)
        self.barseries.setLabelsPosition(QAbstractBarSeries.LabelsInsideEnd)


        self.barchart.addSeries(self.barseries)

        self.barchart.addAxis(self.baraxisY, Qt.AlignLeft)
        self.barseries.attachAxis(self.baraxisY)

        self.barchart.legend().setVisible(True)
        self.barchart.legend().setAlignment(Qt.AlignBottom)

        self.Barchartview.setRenderHint(QPainter.Antialiasing)
        self.Barchartview.setChart(self.barchart)

    def change_barchart(self):

        predDatas = self.FERrec.Detect()[1]
        predDatas = predDatas.cpu()

        # Data = [float('%.4f' % predDatas[0, 0]), float('%.4f' % predDatas[0, 1]),
        #         float('%.4f' % predDatas[0, 2]), float('%.4f' % predDatas[0, 3]),
        #         float('%.4f' % predDatas[0, 4])]
        Data = [float('%.4f' % predDatas[0, 0]), float('%.4f' % predDatas[0, 1]),
                float('%.4f' % predDatas[0, 2]), float('%.4f' % predDatas[0, 3])
                ]

        self.draw_barchart(Data)

    def draw_linechart(self,data):

        self.count = self.count + 1
        self.lineseries0.setName(labLst[0])
        self.lineseries1.setName(labLst[1])
        self.lineseries2.setName(labLst[2])
        self.lineseries3.setName(labLst[3])
        # self.lineseries4.setName(labLst[4])

        self.lineseries0.append(self.count,data[0]*100)
        self.lineseries1.append(self.count,data[1]*100)
        self.lineseries2.append(self.count,data[2]*100)
        self.lineseries3.append(self.count,data[3]*100)
        # self.lineseries4.append(self.count,data[4]*100)


        self.lineseries0.setVisible(True)
        self.lineseries1.setVisible(True)
        self.lineseries2.setVisible(True)
        self.lineseries3.setVisible(True)
        # self.lineseries4.setVisible(True)



        self.linechart.addSeries(self.lineseries0)
        self.linechart.addSeries(self.lineseries1)
        self.linechart.addSeries(self.lineseries2)
        self.linechart.addSeries(self.lineseries3)
        # self.linechart.addSeries(self.lineseries4)

        if self.count < 30:
            self.lineaxisX.setRange(0, 30)
        else:
            self.lineaxisX.setRange(self.count-30,self.count)

        self.lineaxisX.setTickCount(6)
        self.lineaxisX.setTitleText("时间")

        self.lineaxisY.setRange(0,100)
        self.lineaxisY.setTickCount(11)
        self.lineaxisY.setTitleText("各表情识别结果")

        self.lineaxisY.setGridLineVisible(True)
        self.lineaxisY.setGridLineColor(Qt.gray)
        self.lineaxisX.setGridLineVisible(True)
        self.lineaxisX.setGridLineColor(Qt.gray)

        self.linechart.addAxis(self.lineaxisX,Qt.AlignBottom)
        self.linechart.addAxis(self.lineaxisY,Qt.AlignLeft)

        self.lineseries0.attachAxis(self.lineaxisX)
        self.lineseries0.attachAxis(self.lineaxisY)
        self.lineseries1.attachAxis(self.lineaxisX)
        self.lineseries1.attachAxis(self.lineaxisY)
        self.lineseries2.attachAxis(self.lineaxisX)
        self.lineseries2.attachAxis(self.lineaxisY)
        self.lineseries3.attachAxis(self.lineaxisX)
        self.lineseries3.attachAxis(self.lineaxisY)
        # self.lineseries4.attachAxis(self.lineaxisX)
        # self.lineseries4.attachAxis(self.lineaxisY)


        self.linechart.setVisible(True)

        self.Linechartview.setChart(self.linechart)

    def change_linechart(self):

        predDatas = self.FERrec.Detect()[1]
        predDatas = predDatas.cpu()

        # Data = [float('%.4f' % predDatas[0, 0]), float('%.4f' % predDatas[0, 1]),
        #         float('%.4f' % predDatas[0, 2]), float('%.4f' % predDatas[0, 3]),
        #         float('%.4f' % predDatas[0, 4])]
        Data = [float('%.4f' % predDatas[0, 0]), float('%.4f' % predDatas[0, 1]),
                float('%.4f' % predDatas[0, 2]), float('%.4f' % predDatas[0, 3])
                ]
        self.draw_linechart(Data)








class Video_FER():
    def __init__(self, source="0", device='cuda:0', model_name='FERPCVT', out_path='output', has_plt=True):
        global labLst
        self.hasPlt = has_plt
        self.Device = device
        self.outPath = out_path
        self.dbFace = DBFace()
        self.dbFace.load("models/Checkpoint/dbfaceSmallH.pth")
        self.dbFace.eval().to(self.Device)

        self.lab2va = {}
        for i, lab in enumerate(labLst):
            self.lab2va[lab] = i

        self.emotionLab = "NE"
        self.processBuffer = None
        self.outputBuffer = []
        # self.predDatas = None
        self.faceImg = None

        # 情绪识别模型选择
        self.Emodel = None
        self.model_name = model_name
        if self.model_name == 'resnet':
            self.Emodel = Resnet.Res18(pretrained=True, inplanes=224, num_classes=7, drop_rate=0)
            checkpoint = torch.load("models/Checkpoint/resnet-224.pth")
            self.Emodel.load_state_dict(checkpoint["model_state_dict"], strict=False)
            self.imgSize = 224
        else:
            self.Emodel = kvit_pretrained()
            checkpoint = torch.load("models/Checkpoint/kvit-epoch=09-val_acc=0.9921.ckpt")
            self.Emodel.load_state_dict(checkpoint["state_dict"], strict=True)
            self.imgSize = 128
        self.Emodel.to(self.Device).eval()

        # 第一帧测试
        self.Source = source
        if self.Source == "0":
            self.Cap = cv2.VideoCapture(0)
        else:
            self.Cap = cv2.VideoCapture(self.Source)
        self.frameWidth, self.frameHeight = self.Cap.get(3), self.Cap.get(4)
        self.frame = None
        self.frameCount = 0
        self.frameRate = self.Cap.get(5)
        self.Face = None
        self.xTrace, self.yTrace = None, None

    def warp_affine(self, image, face, scale=1.0):
        eye_center = ((face.landmark[0][0] + face.landmark[1][0]) / 2.0,
                      (face.landmark[0][1] + face.landmark[1][1]) / 2.0)
        dy = face.landmark[1][1] - face.landmark[0][1]
        dx = face.landmark[1][0] - face.landmark[0][0]
        # 计算旋转角度
        angle = cv2.fastAtan2(dy, dx)
        rot = cv2.getRotationMatrix2D(eye_center, angle, scale=scale)
        rot_img = cv2.warpAffine(image.copy(), rot, dsize=(image.shape[1], image.shape[0]))
        # cv2.imshow("align_face", rot_img)
        return rot_img

    def faceDetect(self, image, threshold=0.3, nms_iou=0.3):
        def nms(objs, iou=0.5):
            if objs is None or len(objs) <= 1:
                return objs
            objs = sorted(objs, key=lambda obj: obj.score, reverse=True)  # 对序列进行排序
            keep = []
            flags = [0] * len(objs)
            for index, obj in enumerate(objs):  # enumerate 将列表中的每个元素单独拆分出来
                if flags[index] != 0:
                    continue
                keep.append(obj)
                for j in range(index + 1, len(objs)):
                    if flags[j] == 0 and obj.iou(objs[j]) > iou:
                        flags[j] = 1
            return keep

        mean = [0.408, 0.447, 0.47]
        std = [0.289, 0.274, 0.278]
        image = common.pad(image)
        image = ((image / 255.0 - mean) / std).astype(np.float32)
        image = image.transpose(2, 0, 1)

        torch_image = torch.from_numpy(image)[None]
        torch_image = torch_image.to(self.Device)
        hm, box, landmark = self.dbFace(torch_image)
        hm_pool = Functional.max_pool2d(hm, 3, 1, 1)
        scores, indices = ((hm == hm_pool).float() * hm).view(1, -1).cpu().topk(1000)
        hm_height, hm_width = hm.shape[2:]

        scores = scores.squeeze()
        indices = indices.squeeze()
        ys = list((indices / hm_width).int().data.numpy())
        xs = list((indices % hm_width).int().data.numpy())
        scores = list(scores.data.numpy())
        box = box.cpu().squeeze().data.numpy()
        landmark = landmark.cpu().squeeze().data.numpy()

        stride = 4
        objs = []
        for cx, cy, score in zip(xs, ys, scores):
            if score < threshold:
                break

            x, y, r, b = box[:, cy, cx]
            xyrb = (np.array([cx, cy, cx, cy]) + [-x, -y, r, b]) * stride
            x5y5 = landmark[:, cy, cx]
            x5y5 = (common.exp(x5y5 * 4) + ([cx] * 5 + [cy] * 5)) * stride
            box_landmark = list(zip(x5y5[:5], x5y5[5:]))
            objs.append(common.BBox(0, xyrb=xyrb, score=score, landmark=box_landmark))
        return nms(objs, iou=nms_iou)

    def emAnalysis(self, face_img, image_size=128):
        def imgProcess(np_img, imgSize, device):
            test_transformer = transforms.Compose([
                transforms.ToPILImage(),
                transforms.Resize((image_size, image_size)),
                transforms.ToTensor(),
                transforms.Normalize(mean=[0.5, 0.5, 0.5], std=[0.2, 0.2, 0.2])
            ])
            return test_transformer(np_img).to(device)

        img_input = imgProcess(face_img, image_size, self.Device)
        img_input = img_input.unsqueeze(0)
        outputs = self.Emodel(img_input)
        return outputs

    def testDetect(self):
        self.frame = self.Cap.read()[1]
        if self.frame is None:
            return False
        faces = self.faceDetect(self.frame)
        faces.sort(key=lambda x: abs(x.center[0] - self.frameWidth // 2) + abs(x.center[1] - self.frameHeight // 2))
        for face in faces:
            [xcenter, ycenter] = face.center
            if face.score >= 0.75:
                self.Face = face
                [self.xTrace, self.yTrace] = self.Face.center
                return True
        return False

    def normProcess(self, input, banch_size=20, method="means"):
        global labLst
        self.processBuffer = input if self.processBuffer is None else torch.cat((self.processBuffer, input), 0)
        if self.frameCount % self.frameRate == 0:
            if method == "means":
                outputs = torch.mean(self.processBuffer, dim=0)
            elif method == "max":
                outputs = torch.max(self.processBuffer, dim=0)
            # self.predDatas = outputs
            _, predicts = torch.max(outputs, 0)
            self.emotionLab = labLst[predicts]
            VaValue = self.lab2va[self.emotionLab]
            self.outputBuffer.append([self.frameCount // self.frameRate] + [VaValue])

            self.processBuffer = None
        if self.hasPlt:
            # cv2.imshow("Face", self.faceImg)
            common.drawbbox(lable=self.emotionLab, image=self.frame, bbox=self.Face)
        return

    def faceTrace(self, faces, box_scle=1.2, use_affine=True):
        for face in faces:
            [xcenter, ycenter] = face.center
            boxSize = face.width
            xy1 = (int(xcenter - boxSize * box_scle / 2.0), int(ycenter - boxSize * box_scle / 2.0))
            xy2 = (int(xcenter + boxSize * box_scle / 2.0), int(ycenter + boxSize * box_scle / 2.0))
            safecheck = 0 <= xy1[0] and 0 <= xy1[1] and xy2[0] <= self.frameWidth and xy2[1] <= self.frameHeight
            tracecheck = abs(xcenter - self.xTrace) < 40 and abs(ycenter - self.yTrace) < 40
            if face.score >= 0.75 and tracecheck and safecheck:
                self.Face = face
                self.xTrace, self.yTrace = xcenter, ycenter

                if use_affine:
                    img0 = self.warp_affine(self.frame, self.Face, 1.0)
                else:
                    img0 = self.frame[xy1[1]:xy2[1], xy1[0]:xy2[0], :]
                self.faceImg = img0[xy1[1]:xy2[1], xy1[0]:xy2[0], :]
                return True
        return False

    def Detect(self):
        while (self.frame is not None):
            if self.Source == "0":
                self.frameCount += 1
            else:
                self.frameCount = self.Cap.get(1)
            faces = self.faceDetect(self.frame)
            self.faceTrace(faces, box_scle=1.2, use_affine=True)
            predicts = self.emAnalysis(self.faceImg, image_size=self.imgSize)
            self.normProcess(predicts, banch_size=self.frameRate, method="means")
            # count = self.frameCount // self.frameRate
            return self.frame, predicts


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    Mainwindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(Mainwindow)
    Mainwindow.show()
    sys.exit(app.exec_())
